\section{Классы и объекты}
\subsection{Жизненный цикл объекта}
\begin{center}
    \begin{picture}(200,180)
    \put(0,30){\vector(0,1){150}}
    \put(0,30){\vector(1,0){240}}
    \put(230,20){t}
    \put(-30,175){State}
    \put(30,30){\line(0,1){120}}
    \put(30,20){$t_0$}
    \put(20,0){Оператор new}
    \put(60,30){\line(0,1){120}}
    \put(60,20){$t_1$}
    \multiput(30,30)(0,15){7}{\line(1,1){29}}
    \put(60,63){\line(1,1){80}}
    \put(140,30){\line(0,1){120}}
    \put(140,20){$t_2$}
    \multiput(140,30)(0,15){7}{\line(1,1){29}}
    \put(170,30){\line(0,1){120}}
    \put(170,20){$t_3$}
    \put(120,0){Оператор delete}
    \end{picture}
\end{center}

На схеме выше показан примерный 'график' жизни некоторого объекта, сейчас поясним, что на нём есть что:
\begin{enumerate}
    \item Отрезок времени до момента $t_0$: объекта ещё нет.
    \item Отрезок $t_0 - t_1$: с помощью оператора $new$ мы создаём объект. Здесь стоит понимать, что $new$ - это абстракция над выделением памяти и прочими служебными командами, которые бы нам пришлось делать вручную, реши мы работать на более низком уровне. На этапе работы оператора $new$, в частности, отрабатывает некоторый \textit{конструктор} объекта. О конструкторах подробнее речь пойдёт ниже.
    \item Отрезок $t_1 - t_2$: объект живёт, развивается.
    \item Отрезок $t_2 - t_3$: использован оператор $delete$. Здесь также необходимо понимать, что $delete$ - абстракция над рядом служебных команд и вызовов, таких, например, как вызов \textit{деструктора}, а затем высвобождение памяти и возвращение памяти на кучу. В данный отрезок времени происходит вызов деструктора и служебных команд, отвечающих за высвобождение памяти(последнее C++ берёт, как сказано выше, на себя).
    \begin{notice}
        В C++ необходимо, чтобы вся память, выделенная с помощью оператора $new$, была освобождена оператором $delete$. Иначе в памяти так и останется висеть объект, даже после того, как программа отработала и процесс завершился.
    \end{notice}
\end{enumerate}

\subsection{Конструктор и деструктор}

\subsubsection{Конструктор}
\paragraph{Объявление конструктора} не сильно отличается от объявления обычного метода класса. Первое отличие: название конструктора как метода совпадает с названием самого класса. Второе отличие: конструктор не имеет возвращаемого значения!
$\qquad$Обычно конструкторы размещаются в public области класса, но если есть необходимость запретить создание экземпляров класса, то достаточно просто объявить конструктор в private или protected областях, а не в public.
\begin{notice}
    Старайтесь избегать в конструкторах и деструкторах вызова виртуальных функций, поскольку вызывая виртуальную функцию, можно забыть, что при обращении к $this$ мы вызываем последний перегруженный метод (то есть, если в нашем потомке он перегружен, то вызываем его; если не перегружен, то идём вверх по иерархии наследования до первой попавшейся инициализации этого метода).
\end{notice}
\paragraph{Виды конструкторов:} конструктор по умолчанию, конструктор с параметрами, конструктор копирования, конструктор перемещения.

\begin{tabular}{|p{3cm}|p{3cm}|p{9.5cm}|}
\hline
     Название конструктора&Сигнатура&Описание и назначение
     \\
\hline
     Конструктор по умолчанию&className()& Вызывается, если при инициализации объекту не передаётся никаких параметров. Инициализация происходит заранее описанным способом по умолчанию.\\
\hline
    Конструктор с параметрами&className(type1 param1, type2 param2, ...)&Инициализация объекта происходит с учётом переданных внешних параметров.\\
\hline
    Конструктор копирования & className(const ClassName\& Object) & Инициализация объекта происходит путём копирования данных из другого объекта этого же класса согласно описанному в конструкторе алгоритму. При этом \textbf{копируемый объект не меняется}, поэтому и передаётся в конструктор по \textit{константной ссылке}. При копировании данных из одного объекта в другой нельзя 'перевешивать' и нежелательно копировать указатели копируемого объекта в создаваемый, т.к. иначе при уничтожении одного объекта мы рискуем получить 'висячий' указатель (т.е. указатель, к памяти по которому мы уже доступа не имеем, но мы сами об этом не знаем) в другом объекте. Поэтому, если класс имеет поля с указателями, \textbf{нежелательно} использовать конструктор копирования по умолчанию.\\
\hline
     Конструктор копирования по умолчанию(объявление в явном виде) & className(const ClassName\& Object)=default & Просто копирует значение полей из копируемого объекта в инициализируемый.\\
\hline
     Конструктор перемещения & className( ClassName \&\& Object) noexcept & Инициализация объекта происходит путём \textbf{переноса} данных из другого объекта этого же класса. При этом \textbf{передаваемый в конструктор объект меняется}. При переносе данных происходят такие страшные вещи, как перевешивание указателей, перенос кусков памяти жуткими вещами вроде $memcpy$ и прочие непотребства. Нужно это за тем, чтобы при инициализации нового объекта с помощью rvalue не приходилось делать двойную работу: сначала делать копию \textit{временного} объекта, потом убивать её, а потом убивать временный объект. Ведь гораздо дешевле сразу убить временный объект и забрать все его \sout{ценные вещи} данные! Подробнее об этом в разделе по семантике перемещения.\\
\hline

\end{tabular}
\begin{notice}
    В сигнатуре конструктора копирования может стоять ключевое слово explicit. Это будет означать, что компилятору запрещается использовать конструктор копирования неявно (что произойдёт, например, если не перегрузить оператор присваивания и вызвать выражение типа className obj1 = obj2).
\end{notice}
\begin{notice}
    В сигнатуре конструктора перемещения используется параметр $noexcept$, указывающий, что этот конструктор не будет генерировать исключений. Это необходимо вот с какой целью: если исключение генерируется конструктором копирования, то на момент исключения компилятор знает, что копируемый объект не изменился и, по сути, не произошло ничего непоправимого. В случае с конструктором перемещения всё иначе: если произойдёт ошибка в конструкторе перемещения, то компилятор не может понять, на каком шаге программа достигла трагедии: было ли уже что-то перенесено или ещё нет. Это проблема. Поэтому мы насильно говорим, что всё, что было в конструкторе перемещения, остаётся в конструкторе перемещения.
\end{notice}

\subsubsection{Деструктор}
В \textbf{деструкторе}, как понятно из названия, происходит очистка памяти, которую забрал объект для своей жизни. Если объект использует отношение композиции и в нём присутствуют поля с данными на куче, в деструкторе необходимо вызвать оператор $delete$ для каждого такого поля, иначе выделенная для них память так и останется 'висеть' после смерти объекта.
\textbf{Деструктор} не имеет входных параметров, объявляется аналогично конструктору по умолчанию, но перед ним идёт символ '$\sim$'. Т.е. объявление деструктора некоторого класса $className$ будет выглядеть следующим образом:
$$
\sim className();
$$

$\qquad$ Деструктор может быть также по умолчанию(просто используем '$=default$' аналогично тому, как делали в конструкторе копирования).

\subsection{Атрибуты}
\begin{notice}
    Атрибуты появились в C++ начиная лишь с 11 стандарта. Естественно, на лекциях мы их не проходили, и как они оказались в списке тем для экзамена, одному Богу понятно.
\end{notice}
\begin{definition}
    Атрибуты позволяют задавать дополнительную информацию для различных конструкций языка, таких как типы, переменные, имена, блоки и единицы трансляции. Данная информация в частности может быть использована компилятором для генерации более эффективного кода и предоставления (или наоборот, подавления) предупреждающих сообщений пользователю на уровне конкретных участков кода, а не целой программы или компилируемого файла, как это обеспечивается ключами компиляции. 
\end{definition}
Атрибуты указываются перед типом возвращаемого значения функции в виде:
$$
[[atribute\_name]]
$$
\textbf{Список стандартных атрибутов:}
\begin{itemize}
    \item noreturn - функция всегда выдаёт исключение.
    \item carries\_dependency - используется, чтобы позволить зависимостям переноситься через вызовы функций. (я не знаю, что это означает, но пусть будет)
    \item deprecated - используется для пометки сущностей классов или библиотек, которые скоро будут удалены и об использовании которых уже стоит забыть. Генерируется warning.
    \item fallthrough ставится перед case-веткой в switch и указывает, что в данном месте намеренно пропущен break.
    \item nodiscard указывает, что возвращаемое функцией значение нельзя игнорировать и нужно сохранить в какую-либо переменную.
    \item maybe\_unused заставляет компилятор погасить предупреждения о переменной, которая не используется в некоторых режимах компиляции.
    \item likely - разрешить компилятору применить оптимизацию таким образом, что, скорее всего, будет использован метод или функция, помеченная или помеченный этим атрибутом.
    \item no\_unique\_address - я пока не разобрался, что это. Если разобрались, напишите мне в личку.
\end{itemize}

\subsection{Ссылки и ссылочный тип данных, связанные с этим ограничения}

По ссылке ниже представлена краткая статья о том, что такое ссылка в C или C++, этот базис необходимо понимать, чтобы двигаться дальше.

\url{https://ravesli.com/urok-88-ssylki/}

Да-да, тот самый сайт, по заветам дядюшки Яна.


\subsection{MOVE-семантика}
Здесь я не хочу мудрствовать лукаво и просто прикрепляю ссылку на лекционный материал самого Милонова. Тут всё довольно легко и понятно написано, дополнительно есть ссылки на хабр, где можно понять то, что не поняли в самой лекции. Лично мне хватило этой лекции.

\url{http://vega.fcyb.mirea.ru/dist/docs/92i298t-rvalues_and_move_semantic.pdf}

\subsection{Функция и сигнатура}

\begin{definition}
    Сигнатура функции - это описание её заголовка, в которое обычно входят:
    \begin{enumerate}
        \itemимя функции;
        \itemчисло, тип и порядок следоваения передаваемых в неё параметров (в т.ч. и то как именно они передаются, напр. по ссылке или по значению);
        \itemтип возвращаемого значения.
    \end{enumerate}
    
Таким образом, сигнатура - это все что нужно знать (и не более того) о функции вызывающему её коду (т.е. для вызывающего кода важна только сигнатура, сама же реализация может быть черным ящиком).
\end{definition}
$\qquad$Примеры сигнатур функций в ЯП C++:

\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{signature.h}
\begin{notice}
    Думаю, этого более чем достаточно по данному пункту. Более того, если Вы хотя бы раз программировали, этот раздел был лишним для прочтения.
\end{notice}
\newpage
\subsection{Статические, не статические, константные методы}
\begin{definition}
    Статическим методом называется метод, не привязанный ни к одному объекту типа. Перед такими методами в C++ пишут ключевое слово \textbf{static}.
\end{definition}
Такие методы не имеют доступа к указателю $this$ и, следовательно, не могут влиять на состояние одного определённого объекта класса; внутри класса они могут изменять только \textbf{статические поля}. Однако это не мешает вызвать статический метод из какого-нибудь не статического метода класса и получить от него какое-то значение, а затем его использовать внутри этого самого не статического метода.
\begin{definition}
    Константным методом называется метод, который гарантирует, что не будет изменять объект или вызывать неконстантные методы класса. В C++ определяются с помощью идентификатора $const$.
\end{definition}
Пример константного метода-геттера:
$$
    int\text{ }getSize()const\{return\text{ }\_size;\}
$$
\begin{observation}
Как видно из определений выше, статические методы не могут влиять на состояние конкретного объекта, т.е. \textit{статические методы на прямую не изменяют конкретный объект в любом случае}. Поэтому статические методы спокойно могут быть константными (т.е. метод, изменяющий статик-поле, может быть константным).
\end{observation}

\begin{notice}
    Поскольку мы находимся в теме со static значениями, напомню, что static-переменные или поля инициализируются не в заголовочных файлах, т.к. иначе при подключении их ко всем 'заинтересованным' файлам реализации мы получим переопределение одного и того же поля и, как результат, страшную ошибку.
\end{notice}

