\section{ООП, принципы, отношения объектов}
\begin{notice}
Этот раздел - адаптация первой главы опросника по МиСП.
\end{notice}
\subsection{ООП}

    \begin{definition}
    \textbf{Объектно-ориентированный подход} - подход, при котором предметная область представлена совокупностью объектов, взаимодействующих между собой с помощью сообщений.
    \end{definition}
    
    \begin{definition}
    \textbf{Предметная область} - множество предметов и условий, в рамках которых происходит работа и выполнение задачи.
    \end{definition}
    \begin{definition}
    \textbf{Объект} - описание сущности из предметной области.
    \end{definition}
    \begin{definition}
    \textbf{Объектно-ориентированное программирование} - методология программирования, основанная на представлении программы в виде совокупности объектов.
    \end{definition}
    \begin{definition}
    \textbf{Класс} - множество объектов, обладающих общими свойствами и поведением.
    \end{definition}

\subsection{Свойства объекта}
    \begin{itemize}
        
        \item \begin{definition}\textbf{Состояние} - каждая уникальная комбинация свойств объекта(атрибутов) и связей с другими объектами. Меняется со временем.
        \end{definition}
        
        \item \begin{definition}\textbf{Поведение} - определяется методами - определяет действия объекта относительно внешних связей и манипуляций с собственными свойствами.
        \end{definition}
        
        \item \begin{definition}\textbf{Идентичность} - свойство объекта, отличающее его ото всех других объектов. \textit{В C++ это адрес}.
        \end{definition}
    \end{itemize}
    
\subsection{Принципы объектной модели}
\textbf{Основные принципы}:
\begin{itemize}
    \item \begin{definition}\textbf{Абстракция} - выделение наиболее существенных характеристик некоторого объекта, отличающих его от всех других объектов, важных с точки зрения дальнейшего рассмотртения.\end{definition}
    \item \begin{definition}\textbf{Инкапсуляция} - отделение друг от друга элементов объекта, определяющих его устройство и поведение. Служит для изоляции абстракции от реализации.\end{definition} 
    \item \begin{definition}\textbf{Модульность} - возможность спроектировать взаимодействия объектов так, чтобы объекты между собой взаимодействовали неинтенсивно, но внутри самих объектов происходила интенсивная работа. \textit{Используется для переиспользования объектов}.\end{definition}
    \item \begin{definition}\textbf{Иерархия} - упорядочивание абстракций по уровням.\end{definition}
\end{itemize}

\textbf{Дополнительные принципы}:
\begin{itemize}
    \item \begin{definition}\textbf{Типизация} - защита от неправильного использования объекта, т.е. от ситуации, когда объект одного класса используется вместо другого.\end{definition}
    \item \begin{definition}\textbf{Устойчивость} - возможность объекта переживать породивший его процесс.\end{definition}
    \item \begin{definition}\textbf{Параллелизм} - наличие в системе нескольких потоков управления одновременно.\end{definition}
\end{itemize}

\subsection{Принципы объектно-ориентированного программирования}
\subsubsection{Сами принципы}
\begin{enumerate}
    \item \textbf{Абстракция} - см. выше.
    \item \textbf{Инкапсуляция} - см. выше.
    \item \begin{definition}\textbf{Наследование} - механизм создания новых объектов на основе уже существующих путём сохранения свойств и поведения с возможностью расширения функциональности и переопределения.\end{definition}
    \item \begin{definition}\textbf{Полиморфизм} - возможность создавать объекты с одинаковым интерфесом и различной реализацией.\end{definition}
\end{enumerate}
\subsubsection{Примеры и особенности реализации принципов инкапсуляции, наследования и полиморфизма в C++}
\paragraph{Инкапсуляция} в C++ реализуется за счёт разделения атрибутов и методов класса(объекта) на публичные, защищённые и скрытые области видимости, реализующиеся с помощью спецификаторов public, protected и private соответственно.

$\qquad$ В листинге ниже представлен класс $Contact$, публичные переменные и методы доступны из основной программы $(main)$. Приватные переменные и методы могут прочитаны, вызваны или изменены только самим классом.Попытка напечатать или изменить приватную переменную $mobile\_number$ из основной программы $(main)$ вызовет ошибку при компиляции потому как доступ к приватным данным в классе ограничен.
\newpage
\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{encapsulation.cpp}
\newpage
\paragraph{Наследование} в C++ подразделяется на публичное$(public)$, защищённое$(protected)$ и приватное$(private)$.

Разница в следующем:
\begin{itemize}
    \item \textbf{Публичное наследование} - публичные и защищённые данные наследуются без изменения доступа к ним. Т.е. если в исходном классе было поле в защищённой области, то и для наследника это поле останется в защищённой области. Если у предка был публичный метод - он останется публичным и у наследника. 
    \item \textbf{Защищённое наследование} - все поля из public и protected родителя становятся protected-полями потомка.
    \item \textbf{Приватное наследование} - поля public и protected предка становятся полями private потомка.
\end{itemize}
\begin{notice}
    \textbf{Private поля предка ни в каком случае не наследуются!}
\end{notice}

Пример приватного наследования:
\lstset{language=C++}
\lstinputlisting[language=C++]{inheritance.cpp}

$\qquad$Класс $Computer$ теперь использует метод $turn\_on()$ как и любой приватный метод: $turn\_on()$ может быть вызван изнутри класса, но попытка вызвать его напрямую из $main$ приведет к ошибке во время компиляции. Для базового класса $Device$, метод $turn\_on()$ остался публичным, и может быть вызван из $main$.

\begin{notice}
    Более подробно о наследовании в C++, порядке вызовов конструкторов и деструкторов, виртуальном наследовании и прочем подробно написано в соответствующем разделе в материалах по \textit{методам и стандартам программирвания}. В этом же разделе приводятся лишь некоторые общетеоретические моменты.
\end{notice}

\paragraph{Полиморфизм} в C++ зачастую реализуется с помощью механизма наследования абстрактного класса классами с конкретной реализацией методов. Иными словами, существует \textbf{абстрактный класс - класс, в котором есть хотя бы одна чисто виртуальная функция} - от которого так или иначе наследуются другие классы, в которых как раз и создаётся реализация методов, заявленных в абстрактном классе. Также необходимо сказать о таких явлениях, как полиморфные функции: это некоторые функции, способные обрабатывать различные типы входных данных; наверняка Вы помните такие по первому семестру. Конечно, есть и другие проявления полиморфизма. 

\begin{notice}
В данном контексте мы говорим о так называемом \textbf{полиморфизме подтипов}(он же \textbf{Ad-hoc - полиморфизм}). Он заключается в том, что разным типам входных данных соответствует различное поведение.

Также различают так называемый \textbf{параметрический полиморфизм}, его суть в том, что для различных типов данных объект обеспечивает одинаковое поведение. Реализацию этого вида полиморфизма в C++ предлагает механизм шаблонов.

\end{notice}

$\qquad$ Для примера предлагаю рассмотреть нашу с вами лабораторную работу по написанию стека(её ведь все сделали, я надеюсь?). У нас есть абстрактный класс $StackImplementation$, содержащий интерфейс, который должна поддерживать структура, на основе которой работает стек. Уже от этого класса наследуются $VectorStack, ListStack$ - данные классы поддерживают уже реализации на конкретных структурах данных: векторе и списке соответственно. На следующей странице приведены примеры объявления класса $StackImplementation$ и класса $VectorStack$.
\newpage
\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{StackImplementation.h}
\lstset{language=C++, keepspaces = true, extendedchars=\false}
\lstinputlisting[language=C++]{VectorStack.h}

\newpage

\subsection{Типы отношений объектов}
\begin{definition}
    Отношения - способ организации взаимодействия.
\end{definition}

\subsection{Классификация:}
\begin{itemize}
    \item По виду: одно- и дву- направленные;
    \item По характеру: содержит (\textbf{has-a}), является (\textbf{is-a}), использует (\textbf{uses-a});
    \item По кратности: один на один, один объект на много объектов, много на много...
\end{itemize}

\begin{definition}
    \textbf{Интерфейс} - это контракт с системой, гарантирующий определённое поведение и свойства объекта.
\end{definition}

\subsubsection{Типы отношений:}
\begin{tabular}{|c|p{15cm}|}
\hline
     Зависимость& Она же может считаться конкретизацией поведения.
     Рассматривая на примере: один объект обращается к функции другого.
     При этом объекты \textbf{не являются полями друг друга}
     - отношение $(friend)$. Является однонаправленным отношением.
     \\
\hline
     Часть-целое& \begin{definition}
         \textbf{Агрегация} - целое не управляет жизненным циклом частей.
     \end{definition}
     Пример: работник переживает кампанию. Иными словами, если используем агрегацию, то в деструкторе агрегированный объект не удаляем. \textit{has-a}\\
     \cline{2-2}
     & \begin{definition}
         \textbf{Композиция} - часть принадлжеит только одному объекту, который за неё 'отвечает'.
     \end{definition} Пример: часть удаляется в деструкторе объекта-хозяина, а также находится в приватной части. \textit{has-a}\\
\hline
     Ассоциация& Объекты используют друг друга для своих нужд. Отношения двунаправленные, никто никому не принадлежит. Прекрасный пример: отношения врача и пациента - это явно не отношения часть-целое! У врача спокойно может быть огромное количество пациентов в день, а у пациента своя жизнь с блэкджеком и программированием в задачах радиолокации. \textit{uses-a}\\
\hline
     Наследование& Комментарии тут излишни, всё сказали раньше. \textit{is-a} \\
\hline
\end{tabular}
\begin{notice}
    Примеры на C++ для приведённых выше отношений объектов Вы без проблем можете придумать и сами. Поясним только следующее: пример \textbf{зависимости} мы можем найти, вспомнив класс $MyString$, где нам приходилось делать friend-ом класс 'ostream', чтобы работал корректный вывод; \textbf{часть-целое} - односвязный список - в идеале это композиция, ибо в деструкторе мы разрушаем все node в списке; наследование - очевидный пример со стеком; \textbf{агрегация} - возьмём какой-нибудь класс, который имеет полем $std::string$, получим, что класс не несёт ответственности за жизнь этого поля после себя, при этом это поле может быть передано и другим объектам; \textbf{ассоциация} - один класс запрашивает возвращаемые значения методов другого, чтобы конкретизировать свою работу - на пальцах сказать сложно, но если Вам попадётся код с такими отношениями, Вы сразу поймёте.
\end{notice}
\begin{notice}
    Если у Вас всё хорошо с английским и Вы не поняли того, что написано выше, предлагаю прочитать статью по ссылке:
    
    \url{https://www.learncpp.com/cpp-tutorial/10-1-object-relationships/}
\end{notice}
